# 滑动窗口

### 简介

滑动窗口（以下简称滑窗），也就是 Sliding Window，该算法思想如其名，是利用双指针在某种数据结构上（大部分基本上都是 Array）虚构出了一个窗口，并且该窗口还会按规则向后移动，最终找到全局解。相信大家在平常会经常用到，该专题希望大家可以对该思想有一个系统的认识以及训练。

### 目的

该思想的目的是很明确的，可以简单想一下，求数组连续 k 个数的的最大值，若不采用滑窗而采用暴力求解也即如下写法（简单写了核心部分）：

```python
res = -1

for i in range(0, len(n) - k + 1):
    cur_sum = 0
    for j in range(i, i + k):
	cur_sum += n[j]
    res = max(res, cur_sum)

return res
```

不难发现时间复杂度已经达到了$O(N^{2})$，因为我们每移动一次都抛弃了前次的信息并重新计算，效率大打折扣。

相信大家经过了两个月的训练，不难发现，我们每移动向后移动一次大小为 k 的窗口，实际上**变化的只有窗口两端的元素**，也就是说 **新窗口元素和 = 旧窗口元素和 - 左边移除的元素 + 右边进来的元素**，这样就可以写出如下$O(N)$时间复杂度的代码了：

```python
window_sum = sum([elem for elem in n[:k])
res = window_sum

for i in range(k, len(n) - k + 1):
    window_sum = window_sum - n[i] + n[i + k]
    res = max(res, window_sum)

return res
```

这次就利用上了前面计算过的部分信息啦。也就是滑动窗口主要是为了**解决没有利用前置状态计算好的信息而带来的计算复杂度增加的问题**（个人理解哈）。

### 滑窗思想的基本步骤

建立牢记，并按照自己的习惯总结出一套模版或框架。

其实上面的是属于窗口大小固定的解决方案，为的是引出使用该方法的思路历程，当然还有窗口大小不固定的情况，我们可以将算法流程大致抽象出以下三个步骤：

- 向窗口添加元素：需要判断当前情况我们是否需要移动右侧边界来进行添加。
- 从窗口删除元素：需要判断当前情况我们是否需要移动左侧边界来进行删除。
- 更新信息：只要窗口的边界情况发生了改变，我们就需要动态的更新窗口中我们所需的信息。

上面三步可不是线性执行顺序，添加和删除在一些情况可能是连续进行的，也就是第一步或第二部可能有连续执行的情况，只要有第一步或第二步执行过，那么我们就要执行一次第三步。

因此滑动窗口的难点其实需要我们明确在什么情况下移动左/右边界。这里不做过多展开解释，我会选出比较经典的题来给大家练习讲解。

下面给出个参考伪代码：

```python
初始化窗口window

while 右边界 < 合法条件：
    # 右边界扩张
    window右边界+1
    更新状态信息
    # 左边界收缩
    while left < right and 符合收缩条件：
        window左边界+1
        更新状态信息
```

### 注意

需要注意的是，一旦涉及到非定长窗口大小的问题，一般都较难界定何种情况来移动对应指针，所以在 lc 上直观表现就是个 hard 题，但实际上，如果一旦做了出来或者看题解，也很容易发现题目并不难，只是我们没有想清楚而已。

## 总结

滑动窗口核心就是解决没有利用前置状态计算好的信息而带来的计算复杂度增加的问题，因为每次移动窗口变化的其实只是窗口两端的部分，中间的内容是不会变的。

从窗口大小是否可变，我们可将滑动窗口分为**可变滑动窗口**和**固定滑动窗口**，相对来说前者更为复杂，我们需要判断何时更新指针。关于如何更新指针，很难用几句话归纳，因此通过做题来总结是一种好的方式。希望大家在做题的过程多多回顾讲义内容，结合题目攻克滑动窗口难关。
