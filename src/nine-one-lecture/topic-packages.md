# 背包专题

## 简介

背包问题是一类非常经典的动态规划问题，日常使用场景非常灵活。

百度百科定义：背包问题(Knapsack problem)是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过 W 的前提下，总价值是否能达到 V？它是在 1978 年由 Merkle 和 Hellman 提出的。

## 常见题型及对应模版

相信大家现在对动态规划都有了一定的认识和使用，可能部分同学也接触过背包问题，下面给大家归纳几种常用的背包问题及其对应模版，说实话，如果实在理解不了，直接背住模版，把题目对应数据处理一下直接套题目也可以的。

- 01 背包问题：问题描述为有 n 个物品，每个物品对应的重量为 w，价值为 v，问在不超过背包重量 M 的情况下，能够装入物品的最大价值，每个物品只能使用一次。

  简单分析下：因为每个物品要么选要么不选，你要是搜索，那是$2^{N}$复杂度，N 稍微大点就很恐怖了。dp 可以将复杂度降到$O(NW)$，大大简化问题，那么我们来看看状态转移方程如何定义：dp[i][j]表示将前 i 个物品装入承重为 j 的背包可以获得的最大价值。

  那么 dp[i][j]求解时对应以下两种情况

  - 当前第 i 件物品我要了（前提背包要装得下）：dp[i - 1]j - w[i]] + v[i]， w[i]是第 i 个物品的重量，v[i]是第 i 个物品的价值。
  - 当前第 i 件物品我不要：dp[i - 1][j]

  因此可以得到状态转移方程如下：

  $$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]), j>=[i]$$

  通过上述分析可以很容易写出如下代码：

```python
N, M, W, V
dp[0..N][0..M] = 0

for i in 1...N:
    for j in W[i]...M:
        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - W[i]] + V[i]

return dp[N][M]
```

    这种解法其实在部分题中是不能完全AC的，因为空间复杂度是NM，不难发现当前i对应的状态计算只和i - 1有关，我们可以用滚动数组进行优化空间使其降至M，模板如下：

```python
N, M, W, V
dp[0..M] = 0

for i in 1...N:
    for j in M...W[i]: # 这里必须逆向枚举，如果正向的话i状态会覆盖掉i-1的状态
        dp[j] = max(dp[j], dp[j - W[i]] + V[i]

return dp[M]
```

这就是 01 背包问题。

- 完全背包问题：问题描述为有 n 个物品，每个物品对应的重量为 w，价值为 v，问在不超过背包重量 M 的情况下，能够装入物品的最大价值，与 01 背包的区别是每个物品可以使用无限次。

  完全背包问题状态转移方程和 01 背包问题很类似：

  dp[i][j]表示将前 i 个物品装入承重为 j 的背包可以获得的最大价值。

  那么 dp[i][j]求解时对应以下两种情况

  - 当前第 i 件物品我要了（前提背包要装得下）：dp[i]j - w[i]] + v[i]， w[i]是第 i 个物品的重量，v[i]是第 i 个物品的价值。（这里注意，这里是和 01 背包的区别所在，因为当前物品可以无限次被选，因此不应该用 i-1 的状态计算而是继续在 i 状态）
  - 当前第 i 件物品我不要：dp[i - 1][j]

  因此可以得到状态转移方程如下：$$dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]), j>=w[i]$$

  一样，还是可以用滚动数组进行空间上的优化，大致模版如下：

```python
N, M, W, V
dp[0..M] = 0

for i in 1...N:
    for j in W[i]...M: # 这里必须正向枚举，因为当前计算需要dp[i]对应的其他状态来计算
        dp[j] = max(dp[j], dp[j - W[i]] + V[i]

return dp[M]
```

- 多重背包问题：该问题的描述和上面的区别仅仅在于，每个物品的个数有限制

  分析过程和上面也很类似，直接写出状态转移方程：

  $$dp[i][j] = max((dp[i - 1][j - h * w[i]] + h * v[i]) for every h$O

  其中 h 为装入第 i 件物品的个数，h≤min(H[i], j / W[i]), H 为物品及其个数的对应关系。

- 因为装入第 i 物品是从 0-h 计算的，因此 dp[i]需要 dp[i - 1]的状态辅助完成，因此可以采用 01 背包优化的方式来优化空间使用，下面是模板代码：

```python
N, M, W, V, H
dp[0..M] = 0

for i in 1...N:
    for j in M...W[i]: # 这里必须逆向枚举，因为当前计算需要dp[i - 1]对应的其他状态来计算
        for h in 0...min(H[i], j / W[i]):
            dp[j] = max(dp[j], dp[j - h * W[i]] + h * V[i])

return dp[M]
```

## 总结

万变不离其宗，还有背包的很多变形版本，以及不一定求最大价值，dp 的定义以及初始化是很灵活的，后面题目会涉及部分知识。

建议大家把模版翻译成自己擅长的语言，关于背包问题的详细介绍还请查阅背包问题经典的参考资料：[背包九讲第二版](https://github.com/tianyicui/pack/blob/master/V2.pdf)。
